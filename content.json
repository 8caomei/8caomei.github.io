{"meta":{"title":"草莓的博客","subtitle":":-)","description":"YWRtaW5Aa29uZ2Rld2VpLmNu==","author":"草莓丶","url":"http://www.kongdewei.cn"},"pages":[{"title":"分类","date":"2016-09-23T03:42:33.000Z","updated":"2016-09-23T03:43:46.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.kongdewei.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-09-23T03:49:32.000Z","updated":"2016-09-23T06:30:20.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.kongdewei.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"看我如何使用yara扫描webshell","slug":"看我如何使用yara扫描webshell","date":"2017-10-13T01:54:19.000Z","updated":"2017-11-10T10:09:57.000Z","comments":true,"path":"2017/10/13/看我如何使用yara扫描webshell/","link":"","permalink":"http://www.kongdewei.cn/2017/10/13/看我如何使用yara扫描webshell/","excerpt":"前言Yara是一款根据规则库快速匹配文本或程序或进程的工具，杀毒软件早年查杀软件就靠特征匹配，而这个工具就是匹配器，只要你的规则写的足够强大，他可以找出任何符合规则的目标，也就是规则写得好就没有能逃过查杀的Webshell。 githubhttps://github.com/VirusTotal/yara","text":"前言Yara是一款根据规则库快速匹配文本或程序或进程的工具，杀毒软件早年查杀软件就靠特征匹配，而这个工具就是匹配器，只要你的规则写的足够强大，他可以找出任何符合规则的目标，也就是规则写得好就没有能逃过查杀的Webshell。 githubhttps://github.com/VirusTotal/yara windows编译使用github源码直接有windows版本 使用visual studio 2015打开直接生成即可 Debug目录下生成了yara64.exe 运行yara 调用方式 yara64.exe 参数 规则文件 目标文件或目录例如yara64.exe generic_jsp.jar cmd.jspyara64.exe generic_jsp.jar cmd.jsp -s generic_jsp.jar使jspshell的扫描规则。 官方也发布了一些规则 https://github.com/Yara-Rules/rules 具体参数可通过–help查看 Linux编译使用我使用的使ubuntu,从github下载源码后 sudo apt-get install automake libtool make gccsudo apt-get install flex bisonchmod 777 bootstrap.sh./bootstrap.shchmod 777 configure./configuresudo make install 参考：https://yara.readthedocs.io/en/v3.6.0/gettingstarted.html 使用方式跟windows相同这里就不赘述 使用Webshells_index.jar规则扫描下我的jspshell，看下效果还是不错的","categories":[{"name":"yara","slug":"yara","permalink":"http://www.kongdewei.cn/categories/yara/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"http://www.kongdewei.cn/tags/WEB/"}]},{"title":"看我如何搭建一款方便易用的云WAF","slug":"看我如何搭建一款方便易用的云WAF","date":"2017-08-11T03:46:13.000Z","updated":"2017-08-11T03:51:48.000Z","comments":true,"path":"2017/08/11/看我如何搭建一款方便易用的云WAF/","link":"","permalink":"http://www.kongdewei.cn/2017/08/11/看我如何搭建一款方便易用的云WAF/","excerpt":"前言当前市面上各种云WAF，主要作用有两个一个是CDN加速，另一个就是做云防护，原理大概就是把域名IP解析权移交WAF提供商，通过他们访问回目标服务器ip，可以隐藏服务器的真实IP。感谢菜菜指导。 环境：Ubuntu 16.04.1 LTSMysqlNgnix","text":"前言当前市面上各种云WAF，主要作用有两个一个是CDN加速，另一个就是做云防护，原理大概就是把域名IP解析权移交WAF提供商，通过他们访问回目标服务器ip，可以隐藏服务器的真实IP。感谢菜菜指导。 环境：Ubuntu 16.04.1 LTSMysqlNgnix 我们使用的是这款云WAFhttps://waf.xsec.io/https://github.com/xsec-lab 下载与安装直接且到root用户下执行命令 安装openresty apt-get updateapt-get install libreadline-dev libncurses5-dev libpcre3-dev libssl-dev perl make build-essentialsudo ln -s /sbin/ldconfig /usr/bin/ldconfigwget https://openresty.org/download/openresty-1.9.15.1.tar.gztar -zxvf openresty-1.9.15.1.tar.gzcd openresty-1.9.15.1./configuremake &amp;&amp; sudo make install 如果出现如下错误提示解决方法 rm /var/cache/apt/archives/lockrm /var/lib/dpkg/lock 安装 git apt-get install git 安装mysql apt-get install mysql-server 安装vim apt-get install vim 配置root密码，我这里直接写123456了，后面还会在重复填写一次。 waf部署与配置将x-waf的代码目录放置到openresty的/usr/local/openresty/nginx/conf目录下，然后在openresty的conf的目录下新建vhosts目录 cd /usr/local/openresty/nginx/conf/git clone https://github.com/xsec-lab/x-waf.gitmkdir vhosts 备份nginx原配置文件 cp nginx.conf nginx.conf.bakrm nginx.confvim nginx.conf 复制下面的代码，粘贴进去,粘贴进去后保存，然后使用cat命令查看下第一行粘贴是否完整，有的时候第一行会漏掉几个字符，造成nginx报错。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162################user nginx;worker_processes auto;worker_cpu_affinity auto;#error_log logs/error.log;#error_log logs/error.log debug;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 409600;&#125;http &#123; include mime.types; lua_package_path \"/usr/local/openresty/nginx/conf/x-waf/?.lua;/usr/local/lib/lua/?.lua;;\"; lua_shared_dict limit 100m; lua_shared_dict badGuys 100m; default_type application/octet-stream; #开启lua代码缓存功能 lua_code_cache on; init_by_lua_file /usr/local/openresty/nginx/conf/x-waf/init.lua; access_by_lua_file /usr/local/openresty/nginx/conf/x-waf/access.lua; #log_format shield_access '$remote_addr - $http_host - \"$request\" - \"$http_cookie\"'; #access_log pipe:/usr/local/shield/redisclient shield_access; #ssl on; #ssl_certificate certs/cert_chain.crt; #ssl_certificate_key certs/server.key; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; include vhosts/*.conf; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; &#125;&#125; 新建nginx日志目录 cd /var/log/mkdir nginx 测试nginx配置是否正确 /usr/local/openresty/nginx/sbin/nginx -t 出现如下提示则配置正确 启动waf /usr/local/openresty/nginx/sbin/nginx 使用命令访问 curl http://127.0.0.1/\\?id\\=1%20union%20select%201,2,3 浏览器访问 安装后台git上作者提供的教程需要使用go编译，我这里直接提供一个编译好的包。 http://download.csdn.net/download/dad9988/9929074 创建mysql数据库 mysql -u root -pCreate Database waf; 配置后台 tar -xvf x-waf-admin0.1-linux-amd64.tar.gzcd x-waf-admincd confvim app.ini 修改数据库帐号密码，以及API_SERVERS 启动后台,x-waf-admin目录中启动server ./server 默认帐号admin，密码为：x@xsec.io 配置反向代理新增一个后端节点，我这里直接用我的博客http://kongdewei.cn这里的151.101.72.133直接ping自己的域名就可以获得 保存返回，然后选择同步全部后端配置，出现如下提示则配置正确。修改hosts指向 vim /etc/hosts 这里我就直接修改hosts文件指向本地，就不修改域名解析了。 测试访问添加恶意参数查看是否拦截 规则的添加与删除在web后台直接可以操作 总结编写参考https://waf.xsec.io/docs最初安装配置的时候走了一些弯路，在菜菜的指导最终配置成功，关于waf的规则需要自己慢慢收集，最近有人逆向了阿里云waf，有逆向功底的小伙伴可以尝试对成熟的产品进行逆向，挖掘一下他们的规则，添加进去，逆向waf就和他们的一样好用了。","categories":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://www.kongdewei.cn/categories/安全攻防/"},{"name":"网络安全","slug":"安全攻防/网络安全","permalink":"http://www.kongdewei.cn/categories/安全攻防/网络安全/"}],"tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://www.kongdewei.cn/tags/安全攻防/"},{"name":"网络安全","slug":"网络安全","permalink":"http://www.kongdewei.cn/tags/网络安全/"}]},{"title":"逆向修改菜刀过安全狗","slug":"逆向修改菜刀过安全狗","date":"2017-07-22T05:56:23.000Z","updated":"2017-08-13T12:48:51.000Z","comments":true,"path":"2017/07/22/逆向修改菜刀过安全狗/","link":"","permalink":"http://www.kongdewei.cn/2017/07/22/逆向修改菜刀过安全狗/","excerpt":"引子文章是去年写的，现在菜刀过狗也不是很难了，只是做一个逆向修改菜刀的演示。 环境：Windows2003中间件：iis6.0安全狗版本：安全狗iis枸杞版3.5菜刀：chopper.exe md5: e2caee9b7844ea06d964ad138d1da1f9工具：吾爱破解专用版Ollydbg，LordPE，C32ASM","text":"引子文章是去年写的，现在菜刀过狗也不是很难了，只是做一个逆向修改菜刀的演示。 环境：Windows2003中间件：iis6.0安全狗版本：安全狗iis枸杞版3.5菜刀：chopper.exe md5: e2caee9b7844ea06d964ad138d1da1f9工具：吾爱破解专用版Ollydbg，LordPE，C32ASM 尝试主要是为了绕过安全狗的一句话检测，开启这个就行了。 在IIS目录放一句话木马。 GIF89&lt;%eval request(“1”)%&gt; 最普通的那种，并没有各种乱七八糟的变形之类的。通过浏览器访问。 正常的，并没有被拦截。添加到菜刀列表，访问试试看。 通过菜刀访问，被安全狗拦截了，打开fiddler看看封包。 分析修改 因为以前做过免杀，所以最早的时候没有各种工具可以定位，我是通过OD的一半一半法来定位被查杀的位置。AAAAAAAAAAAAAAABBAAAAAAAAAAAAAAA我当时的想法是，能不能运用在过WAF上，先把特征码对半，然后慢慢对被检测的补位进行定位。 去掉一般的封包重发，还是被拦截，看来特征在前半段。 已经没有被拦截的提示，但是程序也是报错了，毕竟代码不完整，于是我想到了之前过安全狗的SQL注入是通过加很长很长的字符，然后就能绕过SQL注入检测，那么如果我给这段封包加很长的字符是不是也可以绕过。 通过增加很长的前缀，就过掉了安全狗，但是如果我每个封包都这样拦截修改是不是太麻烦了。于是我想到了通过OD修改。 原版的菜刀并没有加壳，可以直接修改，打开OD查看下字符串。 这个位置是ASP的原版字符串，通过这里修改就可以修改他的发包，但是因为需要增加的长多比较大，所以原程序并没有那么大的空地址段给我写，要自己另外增加区段。上C32，新建一个文件，然后把前面的字符加进来。 区段做好了，然后用PEid把区段加到程序里。 然后通过OD修改，字符串偏移位置。 这里是004ab000 保存下文件，然后用fiddler抓包查看是否天然带我们的字符串。 通过修改发包已经天然带字符串，当然不止修改一个地方，要完成ASP完成可用要修改好几处位置。 总结刚开始我认为这些waf是完美的，后来我发现，这些防火墙有些类似于早点的杀毒软件，通过特征库来拦截，只要找对特征，就可以对症下药，不同品牌的防火墙规则不同，但是换汤不换药基本都是这样的套路，兵来将敌水来土堰靠规则并不靠谱，修改web程序中的漏洞才是关键，过度依赖防火墙并不能很好的保护网站。jsp与php 版过防火墙：PyCmd 加密隐形木马","categories":[{"name":"逆向分析","slug":"逆向分析","permalink":"http://www.kongdewei.cn/categories/逆向分析/"},{"name":"网络安全","slug":"逆向分析/网络安全","permalink":"http://www.kongdewei.cn/categories/逆向分析/网络安全/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://www.kongdewei.cn/tags/网络安全/"},{"name":"逆向分析","slug":"逆向分析","permalink":"http://www.kongdewei.cn/tags/逆向分析/"}]},{"title":"【CrackMe】CTF题目-winodws逆向寻找flag","slug":"【CrackMe】CTF题目-winodws逆向寻找flag","date":"2017-07-15T08:07:30.000Z","updated":"2017-08-13T12:47:47.000Z","comments":true,"path":"2017/07/15/【CrackMe】CTF题目-winodws逆向寻找flag/","link":"","permalink":"http://www.kongdewei.cn/2017/07/15/【CrackMe】CTF题目-winodws逆向寻找flag/","excerpt":"前言这题目是命令行输入，OD关键位置时候有别于窗口程序，刚开始我是结合CE找到关键点。 程序下载地址：http://download.csdn.net/detail/dad9988/9899751难度：★使用工具：ollydbg吾爱破解专版运行环境：windows 7 x64","text":"前言这题目是命令行输入，OD关键位置时候有别于窗口程序，刚开始我是结合CE找到关键点。 程序下载地址：http://download.csdn.net/detail/dad9988/9899751难度：★使用工具：ollydbg吾爱破解专版运行环境：windows 7 x64 程序截图之前在一个ctf平台上下载题目。 错误提示 正确提示 验证方式通过命令行输入flag，程序对输入信息进行加密运算后与存放在程序内的加密后数值进行比对。 分析过程一般载入程序跑起来之后是用过E标签，跳转到程序领空，再寻找关键字符串信息。 但这是命令行程序，载入直接就在程序领空，查找字符串 很容易看到一串很可能是flag的东西，直接拿来输入试试看。 e3nifIH9b_C@n@dH 提示错误，并不是那么简单直接进行明文字符对比。 在提示输入flag的地方下断1011B5758 68 747B1B01 push reverse_.011B7B74 ; please enter the flag: F8步下，随意输入123456回车继续F8步下 关键运算如下 123456789101112131415161718192021222324252627282930011B578F E8 2AB9FFFF call reverse_.011B10BE ; //进行Base64编码011B5794 83C4 0C add esp,0xC011B5797 50 push eax011B5798 8D85 6CFFFFFF lea eax,dword ptr ss:[ebp-0x94]011B579E 50 push eax011B579F FF15 88B11B01 call dword ptr ds:[&lt;&amp;ucrtbased.strncpy&gt;] ; ucrtbase.strncpy011B57A5 83C4 0C add esp,0xC011B57A8 3BF4 cmp esi,esp011B57AA E8 78B9FFFF call reverse_.011B1127011B57AF 8D85 6CFFFFFF lea eax,dword ptr ss:[ebp-0x94]011B57B5 50 push eax011B57B6 E8 0DB9FFFF call reverse_.011B10C8011B57BB 83C4 04 add esp,0x4011B57BE 8985 60FFFFFF mov dword ptr ss:[ebp-0xA0],eax011B57C4 C785 54FFFFFF 0&gt;mov dword ptr ss:[ebp-0xAC],0x0 ; //开始循环011B57CE EB 0F jmp short reverse_.011B57DF011B57D0 8B85 54FFFFFF mov eax,dword ptr ss:[ebp-0xAC]011B57D6 83C0 01 add eax,0x1 ; 每次循环eax++011B57D9 8985 54FFFFFF mov dword ptr ss:[ebp-0xAC],eax011B57DF 8B85 54FFFFFF mov eax,dword ptr ss:[ebp-0xAC]011B57E5 3B85 60FFFFFF cmp eax,dword ptr ss:[ebp-0xA0] ; 判断不超过字符串长度则继续011B57EB 7D 23 jge short reverse_.011B5810011B57ED 8B85 54FFFFFF mov eax,dword ptr ss:[ebp-0xAC]011B57F3 0FBE8C05 6CFFFF&gt;movsx ecx,byte ptr ss:[ebp+eax-0x94] ; 每次取一位字符串的hex+eax011B57FB 038D 54FFFFFF add ecx,dword ptr ss:[ebp-0xAC]011B5801 8B95 54FFFFFF mov edx,dword ptr ss:[ebp-0xAC]011B5807 888C15 6CFFFFFF mov byte ptr ss:[ebp+edx-0x94],cl ; 重新赋值给 字符串[eax]011B580E ^ EB C0 jmp short reverse_.011B57D0011B5810 8D85 6CFFFFFF lea eax,dword ptr ss:[ebp-0x94]011B5816 50 push eax 最后在这里进行判断123456789011B581C 83C4 04 add esp,0x4011B581F 8BF4 mov esi,esp011B5821 50 push eax011B5822 68 34A01B01 push reverse_.011BA034 ; e3nifIH9b_C@n@dH011B5827 8D8D 6CFFFFFF lea ecx,dword ptr ss:[ebp-0x94]011B582D 51 push ecx011B582E FF15 84B11B01 call dword ptr ds:[&lt;&amp;ucrtbased.strncmp&gt;] ; ucrtbase.strncmp011B5834 83C4 0C add esp,0xC011B5837 3BF4 cmp esi,esp 关于strncmp的解释 strncmpint strncmp ( const char str1, const char str2, size_t n );【参数】str1, str2 为需要比较的两个字符串，n为要比较的字符的数目。【返回值】若str1与str2的前n个字符相同，则返回0；若s1大于s2，则返回大于0的值；若s1 若小于s2，则返回小于0的值。 爆破关键点1234567891011011B5837 3BF4 cmp esi,esp011B5839 E8 E9B8FFFF call reverse_.011B1127011B583E 85C0 test eax,eax011B5840 74 0F je short reverse_.011B5851 ; //爆破关键点011B5842 68 947B1B01 push reverse_.011B7B94 ; wrong flag!\\n011B5847 E8 E3BAFFFF call reverse_.011B132F011B584C 83C4 04 add esp,0x4011B584F EB 0D jmp short reverse_.011B585E011B5851 68 4C7C1B01 push reverse_.011B7C4C ; rigth flag!\\n011B5856 E8 D4BAFFFF call reverse_.011B132F011B585B 83C4 04 add esp,0x4 解题代码从上面的分析得出，该题通俗点说就是把输入的字符串进行 Base64编码，根据编码后的长度对编码后的字符串进行逐位加增加。增加规则为 第0位+0x00 第1位+0x01 ….. 第N位+0x0N最后对比的字符串为 e3nifIH9b_C@n@dH python代码12345678#coding=utf-8import binascii,base64strA = 'e3nifIH9b_C@n@dH'strB = ''for num in range(0,len(strA)): strB = strB + chr(int(binascii.b2a_hex(strA[num]),16) - num)print base64.b64decode(strB) 运行结果 flag是： {i_l0ve_you} 测试是否正确 总结加密后的flag不是很长，有耐心的同学直接用calc计算也可以争取的结果，flag是表白么？如果做题的是妹子感觉也是很不错的。PS:别做梦了，妹子会玩windows逆向么？/滑稽脸","categories":[{"name":"ctf","slug":"ctf","permalink":"http://www.kongdewei.cn/categories/ctf/"},{"name":"CrackMe","slug":"ctf/CrackMe","permalink":"http://www.kongdewei.cn/categories/ctf/CrackMe/"},{"name":"逆向分析","slug":"ctf/CrackMe/逆向分析","permalink":"http://www.kongdewei.cn/categories/ctf/CrackMe/逆向分析/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.kongdewei.cn/tags/ctf/"},{"name":"CrackMe","slug":"CrackMe","permalink":"http://www.kongdewei.cn/tags/CrackMe/"}]},{"title":"【CrackMe】Acid burn追码写注册机","slug":"【CrackMe】Acid burn追码写注册机","date":"2017-07-07T00:49:41.000Z","updated":"2020-01-07T06:10:14.588Z","comments":true,"path":"2017/07/07/【CrackMe】Acid burn追码写注册机/","link":"","permalink":"http://www.kongdewei.cn/2017/07/07/【CrackMe】Acid burn追码写注册机/","excerpt":"前言暴力破解虽然很爽，但追码写注册机才是技术活，在吾爱找到一个CrackMe集合，有160个，打算慢慢研究慢慢写，如果我都能解出来的话。 程序下载地址：http://download.csdn.net/detail/dad9988/9891206难度：★使用工具：ollydbg吾爱破解专版运行环境：windows 7 x64","text":"前言暴力破解虽然很爽，但追码写注册机才是技术活，在吾爱找到一个CrackMe集合，有160个，打算慢慢研究慢慢写，如果我都能解出来的话。 程序下载地址：http://download.csdn.net/detail/dad9988/9891206难度：★使用工具：ollydbg吾爱破解专版运行环境：windows 7 x64 程序截图这个集合第一个作者是Acid burn 正确提示 错误提示 验证方式需要输入username与key，程序会根据username计算key，符合规则则弹出正确提示。 分析过程从截图很容易看出来这个CrackMe是利用消息框反馈结果，直接下消息框断点，返回程序领空。 123450042F998 /. 55 push ebp0042F999 |. 8BEC mov ebp,esp0042F99B |. 33C9 xor ecx,ecx0042F99D |. 51 push ecx0042F99E |. 51 push ecx 12345678910111213141516171819202122232425262728293031323334353637383940414243440042F9C8 |. E8 8BB0FEFF call Acid_bur.0041AA58 ; 得到输入的username0042F9CD |. 8B45 F0 mov eax,[local.4]0042F9D0 |. E8 DB40FDFF call Acid_bur.00403AB00042F9D5 |. A3 6C174300 mov dword ptr ds:[0x43176C],eax ; username存入0x43176c0042F9DA |. 8D55 F0 lea edx,[local.4]0042F9DD |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042F9E3 |. E8 70B0FEFF call Acid_bur.0041AA580042F9E8 |. 8B45 F0 mov eax,[local.4]0042F9EB |. 0FB600 movzx eax,byte ptr ds:[eax] ; 取第一位0042F9EE |. 8BF0 mov esi,eax0042F9F0 |. C1E6 03 shl esi,0x3 ; esi左移三位 esi=1880042F9F3 |. 2BF0 sub esi,eax ; eax=esi-eax0042F9F5 |. 8D55 EC lea edx,[local.5]0042F9F8 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042F9FE |. E8 55B0FEFF call Acid_bur.0041AA580042FA03 |. 8B45 EC mov eax,[local.5]0042FA06 |. 0FB640 01 movzx eax,byte ptr ds:[eax+0x1] ; 取第二位0042FA0A |. C1E0 04 shl eax,0x4 ; eax左移四位0042FA0D |. 03F0 add esi,eax ; 加上上次运算的结果0042FA0F 8935 54174300 mov dword ptr ds:[0x431754],esi ; 存放到 0x4317540042FA15 |. 8D55 F0 lea edx,[local.4]0042FA18 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA1E |. E8 35B0FEFF call Acid_bur.0041AA580042FA23 |. 8B45 F0 mov eax,[local.4]0042FA26 |. 0FB640 03 movzx eax,byte ptr ds:[eax+0x3] ; 取第四位0042FA2A |. 6BF0 0B imul esi,eax,0xB ; esi=eax*0xB0042FA2D |. 8D55 EC lea edx,[local.5]0042FA30 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA36 |. E8 1DB0FEFF call Acid_bur.0041AA580042FA3B |. 8B45 EC mov eax,[local.5]0042FA3E |. 0FB640 02 movzx eax,byte ptr ds:[eax+0x2] ; 取第三位0042FA42 |. 6BC0 0E imul eax,eax,0xE ; eax=eax*0xE0042FA45 |. 03F0 add esi,eax ; 加上第四位运算结果0042FA47 |. 8935 58174300 mov dword ptr ds:[0x431758],esi ; 存放到0x4317580042FA4D |. A1 6C174300 mov eax,dword ptr ds:[0x43176C]0042FA52 |. E8 D96EFDFF call Acid_bur.004069300042FA57 |. 83F8 04 cmp eax,0x4 ; //判断输入的用户名小于4位则提示错误---------0042FA5A |. 7D 1D jge short Acid_bur.0042FA790042FA5C |. 6A 00 push 0x00042FA5E |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again!0042FA63 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect !0042FA68 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FA6D |. 8B00 mov eax,dword ptr ds:[eax]0042FA6F |. E8 FCA6FFFF call Acid_bur.0042A170 刚开始我认识这段程序反复取值进行运算，并存放起来，在后面肯定会用到，结果发现他最后只是进行一个长度是否为4位的判断，之后的运算也并没有用到这里的计算结果，很坑。 12345678910111213141516171819200042FA87 |. 8B45 F0 mov eax,[local.4] ; 输入的内容存入EAX0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; 取第一位存入EAX0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750]0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; [0x431750]=EAX*[0x431750]*20042FAA3 |. 8D45 FC lea eax,[local.1]0042FAA6 |. BA ACFB4200 mov edx,Acid_bur.0042FBAC ; CW0042FAAB |. E8 583CFDFF call Acid_bur.004037080042FAB0 |. 8D45 F8 lea eax,[local.2]0042FAB3 |. BA B8FB4200 mov edx,Acid_bur.0042FBB8 ; CRACK0042FAB8 |. E8 4B3CFDFF call Acid_bur.004037080042FABD |. FF75 FC push [local.1]0042FAC0 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FAC5 |. 8D55 E8 lea edx,[local.6]0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FACD |. E8 466CFDFF call Acid_bur.00406718 ; ////////////////////某种计算规则0042FAD2 |. FF75 E8 push [local.6]0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FADA |. FF75 F8 push [local.2] ; msctf.752379E5 [0x431750]=EAX[0x431750]20x431750在程序开头会直接赋值0x29 mov dword ptr ds:[0x431750],0x29 最后一段，关键点在于某种算法规则这里。1234567891011121314151617181920212223242526270042FACD |. E8 466CFDFF call Acid_bur.00406718 ; ////////////////////某种计算规则0042FAD2 |. FF75 E8 push [local.6]0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FADA |. FF75 F8 push [local.2]0042FADD |. 8D45 F4 lea eax,[local.3]0042FAE0 |. BA 05000000 mov edx,0x50042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC0042FAEA |. 8D55 F0 lea edx,[local.4]0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA580042FAF8 |. 8B55 F0 mov edx,[local.4]0042FAFB |. 8B45 F4 mov eax,[local.3]0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC0042FB03 |. 75 1A jnz short Acid_bur.0042FB1F0042FB05 |. 6A 00 push 0x00042FB07 |. B9 CCFB4200 mov ecx,Acid_bur.0042FBCC ; Congratz !!0042FB0C |. BA D8FB4200 mov edx,Acid_bur.0042FBD8 ; Good job dude =)0042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FB16 |. 8B00 mov eax,dword ptr ds:[eax]0042FB18 |. E8 53A6FFFF call Acid_bur.0042A1700042FB1D |. EB 18 jmp short Acid_bur.0042FB370042FB1F |&gt; 6A 00 push 0x00042FB21 |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again!0042FB26 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect !0042FB2B |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FB30 |. 8B00 mov eax,dword ptr ds:[eax]0042FB32 |. E8 39A6FFFF call Acid_bur.0042A170 0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC 这里为最终判断call，会比对生成的key与我输入的key，进行判断，暴力破解的话直接修改这里。 0042FB03 |. /75 1A jnz short Acid_bur.0042FB1F 最终生成key算法。12345678910111213141516171800406DC2 |$ B9 0A000000 mov ecx,0xA ; Case 55 ('U') of switch 00406D9A00406DC7 |&gt; 8D75 C4 lea esi,[local.15]00406DCA |&gt; 31D2 /xor edx,edx00406DCC |. F7F1 |div ecx ; 计算循环----------00406DCE |. 80C2 30 |add dl,0x3000406DD1 |. 80FA 3A |cmp dl,0x3A00406DD4 |. 72 03 |jb short Acid_bur.00406DD900406DD6 |. 80C2 07 |add dl,0x700406DD9 |&gt; 4E |dec esi00406DDA |. 8816 |mov byte ptr ds:[esi],dl00406DDC |. 09C0 |or eax,eax00406DDE |.^ 75 EA \\jnz short Acid_bur.00406DCA00406DE0 |. 8D4D C4 lea ecx,[local.15]00406DE3 |. 29F1 sub ecx,esi00406DE5 |. 8B55 E0 mov edx,[local.8]00406DE8 |. 83FA 10 cmp edx,0x1000406DEB |. 72 01 jb short Acid_bur.00406DEE00406DED |. C3 retn xor edx,edxdiv ecx //这里与eax进行运算 eax取自12345670042FA87 |. 8B45 F0 mov eax,[local.4] ; 输入的内容存入EAX0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; 取第一位存入EAX0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750]0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; [0x431750]=EAX*[0x431750]*20042FAA3 |. 8D45 FC lea eax,[local.1] 根据算法写python脚本123456789101112131415#coding=utf-8#coding=utf-8import binasciistrUserName = raw_input(\"userNaem: \")a = int(binascii.b2a_hex(strUserName[0]),16) * int('0x29',16) * 2print str(hex(a))strA = ''for i in range(0,4): b = a % 10 a = a / 10 strA = str(b) + strAprint 'CW-' + str(strA) + '-CRACKED' 总结细心的人其实已经看出来了，123b = a % 10a = a / 10strA = str(b) + strA 这不就是他本身么，OD跟踪的时候是十六进制，最后进入一个call，这个call的作用就是进制转换。1234567891000406DCA |&gt; /31D2 /xor edx,edx00406DCC |. |F7F1 |div ecx ; 计算循环----------00406DCE |. |80C2 30 |add dl,0x3000406DD1 |. |80FA 3A |cmp dl,0x3A00406DD4 |. |72 03 |jb short Acid_bur.00406DD900406DD6 |. |80C2 07 |add dl,0x700406DD9 |&gt; |4E |dec esi00406DDA |. |8816 |mov byte ptr ds:[esi],dl00406DDC |. |09C0 |or eax,eax00406DDE |.^\\75 EA \\jnz short Acid_bur.00406DCA key计算可以优化一下123456#coding=utf-8import binasciistrUserName = raw_input(\"userNaem:\")a = int(binascii.b2a_hex(strUserName[0]),16) * int('0x29',16) * 2print 'CW-' + str(a) + '-CRACKED'","categories":[{"name":"ctf","slug":"ctf","permalink":"http://www.kongdewei.cn/categories/ctf/"},{"name":"CrackMe","slug":"ctf/CrackMe","permalink":"http://www.kongdewei.cn/categories/ctf/CrackMe/"},{"name":"逆向分析","slug":"ctf/CrackMe/逆向分析","permalink":"http://www.kongdewei.cn/categories/ctf/CrackMe/逆向分析/"}],"tags":[{"name":"CrackMe","slug":"CrackMe","permalink":"http://www.kongdewei.cn/tags/CrackMe/"}]},{"title":"Android Studio动态调试Smail","slug":"Android-Studio动态调试Smail","date":"2017-07-03T07:33:15.000Z","updated":"2017-07-03T13:07:58.000Z","comments":true,"path":"2017/07/03/Android-Studio动态调试Smail/","link":"","permalink":"http://www.kongdewei.cn/2017/07/03/Android-Studio动态调试Smail/","excerpt":"首发：Android Studio动态调试Smail 0x00 前言DDCTF安卓题调试上一次是静态修改，后来我在想能不能动态调试得到Flag，于是就有了这篇文章。 apk下载地址http://download.csdn.net/detail/dad9988/9887419","text":"首发：Android Studio动态调试Smail 0x00 前言DDCTF安卓题调试上一次是静态修改，后来我在想能不能动态调试得到Flag，于是就有了这篇文章。 apk下载地址http://download.csdn.net/detail/dad9988/9887419 0x01 准备工作下载、安装android studio https://dl.google.com/dl/android/studio/install/2.3.2.0/android-studio-bundle-162.3934792-windows.exe 非常神奇，可以不翻(河蟹)墙下载,看来G(河蟹)F(河蟹)W对程序员还是很友善的。android studio集成了所需要的东西，以前eclipse需要另外装各种东西方便很多。 下载、安装模拟器 推荐使用这款模拟器https://www.yeshen.com/ 模拟器安装就不赘述了。 改之理很多apk解包使用apktools.jar会出现各种问题，直接用ide会方便很多。 下载地址： http://www.52pojie.cn/thread-399571-1-1.html 0x02 实战操作解包与导入工程到Android Studio首先使用apk改之理解包，直接用改之理打开apk包即可，改之理目录下就会有解包后的文件。 work目录下是解包后的文件 打开Android Studio选Import project 选择刚才的解包目录 直接next到底 导入后会有一段时间的加载文件。 安装smalideaFile—&gt;Settings—&gt;Install plugin from disk 下载smalidea-0.05.zip(这一步只需要做一次)https://bitbucket.org/JesusFreke/smali/downloads/ 选择刚下载的smalidea-0.05.zip 导入需要重启一下。 寻找命令行启动参数改之理解包目录下打开AndroidManifest.xml,记录activity层的android:name值。 adb shell启动apk运行模拟器，在Android Studio中启动android device monitor 一般会自动链接到ADM中，如果没有自动链接上去使用以下命令进行链接。 我推荐的这个模拟器是链接62001其他模拟器自查adb connect 127.0.0.1:62001 安装apk到模拟器（apk直接拉进去就自动安装了），并使用命令启动apk（adb如果未找到命令，请百度如何解决。） adb shell am start -D -n com.didictf.hellolibs/com.didictf.hellolibs.MainActivity 运行命令后可通过adm看到有个红色的虫子图标，这个时候apk已经挂起等待调试了。 在MainActivity下的OnCreate函数下断点 点击如图的三角，选择Edit Configurations 点击加号，选择Remote 修改port为8700点击OK 点击调试按钮挂载到模拟器中 已经断在我们下的断点。 0x03 调试DDCTF安卓题调试 上一篇文章分析得出关键位置在MainActivity中的onClickTest函数，这次我们直接在这里下断点，动态调试。 模拟器随便输入，点击test按钮，就会断在我们下的地方 点击如图加号添加v0 ,v1,p0监视变量，并F8单步向下，走到58行，就会从so中返回flag到系统apk的v1变量中。 对比下反编译的源码，更容易分析apk的工作流程。 0x04 总结对于这个CTF的apk，动态调试会更加直观，下好断点，添加监视变量直接但步向下即可，比静态修改重新打包来的方便。 转载请注明出处。","categories":[{"name":"移动安全android","slug":"移动安全android","permalink":"http://www.kongdewei.cn/categories/移动安全android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.kongdewei.cn/tags/Android/"}]},{"title":"DDCTF安卓题-writeup","slug":"DDCTF安卓题-writeup","date":"2017-06-30T06:00:11.000Z","updated":"2020-01-07T06:15:28.064Z","comments":true,"path":"2017/06/30/DDCTF安卓题-writeup/","link":"","permalink":"http://www.kongdewei.cn/2017/06/30/DDCTF安卓题-writeup/","excerpt":"0x01 引子前段做了一个滴滴CTF的其中一道安卓题目，题目并不难，主要分享一下做题过程和思路。","text":"0x01 引子前段做了一个滴滴CTF的其中一道安卓题目，题目并不难，主要分享一下做题过程和思路。 0x02 要求与提示赛题背景：本挑战结合了Android, Java, C/C++，加密算法等知识点，考察了挑战者的binary逆向技术和加密算法能力。 赛题描述：本题是一个app，请试分析app中隐藏的key，逆向加密算法并得到对应的秘钥。可以在app中尝试输入key，如果正确会显示“correct”，如果错误会显示“Wrong”。提 示：阅读assembly code，理解xor的加密逻辑和参数，解出答案。评分标准：key正确则可进入下一题。 Flag格式为DDCTF-XXXXXXXXXXXX@didichuxing.com 还是很好辨认的 0x03 分析与过程 直接点击下方的TEST按钮显示Wrong上apkkiller找到关键位置，进行关键词搜索（搜Wrong）。 反编译源码（appkiller上点击java图标） 这里直接贴上来代码123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity&#123; private TextView mFlagEntryView; private TextView mFlagResultView; static &#123; System.loadLibrary(\"hello-libs\"); &#125; public void onClickTest(View paramView) &#123; if (this.mFlagEntryView.getText().toString().equals(stringFromJNI())) &#123; this.mFlagResultView.setText(\"Correct\"); &#125; for (;;) &#123; return; this.mFlagResultView.setText(\"Wrong\"); &#125; &#125; protected void onCreate(Bundle paramBundle) &#123; super.onCreate(paramBundle); setContentView(2130968602); this.mFlagEntryView = ((TextView)findViewById(2131427413)); this.mFlagResultView = ((TextView)findViewById(2131427415)); &#125; public native String stringFromJNI();&#125; 其中onClickTest响应TEST按钮点击 this.mFlagEntryView.getText().toString().equals(stringFromJNI()) 从mFlagEntryView得到view控件内容，tostring转string型，使用equals对比stringFromJNI()返回值。 一般我们应该跟踪stringFromJNI()函数看他返回了什么值，接下来查找该函数的来源 static { System.loadLibrary(“hello-libs”); } 加载了so模块hello-libs 这个时候分析so文件获取flag就行了。 这里很简单并没有加什么混淆，直接写在so文件中，到这里就算完成这题。 0x04 另一种思路如果这个题目的so中是经过运算加密返回的，并无法直接静态看到flag那该怎么办。 this.mFlagEntryView.getText().toString().equals(stringFromJNI()) 前面我们分析过这个位置，因为使用equals进行字符串对比。看下equals的java解释 Equals之前使用了tostring，所以如果mFlagEntryView的内容与stringFromJNI返回值相同才会出现true的情况，那么也就是说stringFromJNI是把flag返回到程序领空的，我们直接修改smil代码把flag显示在mFlagResultView中。 直接获取stringFromJNI返回值然后赋值给mFlagResultView，再安装运行即可。","categories":[{"name":"移动安全android","slug":"移动安全android","permalink":"http://www.kongdewei.cn/categories/移动安全android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.kongdewei.cn/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-09-23T06:23:59.000Z","updated":"2017-06-30T13:55:06.000Z","comments":true,"path":"2016/09/23/hello-world/","link":"","permalink":"http://www.kongdewei.cn/2016/09/23/hello-world/","excerpt":"0Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"0Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://www.kongdewei.cn/categories/test/"}],"tags":[{"name":"你好世界","slug":"你好世界","permalink":"http://www.kongdewei.cn/tags/你好世界/"}]}]}